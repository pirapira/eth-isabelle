(*Generated by Lem from lem/word32.lem.*)
(*
  Copyright 2016 Sami MÃ¤kelÃ¤

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*)

open Lem_pervasives
open Lem_word

type word32 = W32 of bool * bool list

(* perhaps should truncate here? *)
(*val bs_to_w32 : bitSequence -> word32*)
let bs_to_w32 seq:word32=  ((match resizeBitSeq (Some( 32)) seq with
 | BitSeq( _, s, b) -> W32( s, b)
))

(*val w32_to_bs : word32 -> bitSequence*)
let w32_to_bs (W32( s, b)):bitSequence=  (BitSeq( (Some( 32)), s, b))

(*val word32BinTest : forall 'a. (bitSequence -> bitSequence -> 'a) -> word32 -> word32 -> 'a*)
let word32BinTest binop w1 w2:'a=  (binop (w32_to_bs w1) (w32_to_bs w2))

(*val word32BinOp : (bitSequence -> bitSequence -> bitSequence) -> word32 -> word32 -> word32*)
let word32BinOp binop w1 w2:word32=  (bs_to_w32 (binop (w32_to_bs w1) (w32_to_bs w2)))

(*val word32NatOp : (bitSequence -> nat -> bitSequence) -> word32 -> nat -> word32*)
let word32NatOp binop w1 n:word32=  (bs_to_w32 (binop (w32_to_bs w1) n))

(*val word32UnaryOp : (bitSequence -> bitSequence) -> word32 -> word32*)
let word32UnaryOp op w:word32=  (bs_to_w32 (op (w32_to_bs w)))

(*val size32 : integer*)
let size32:Nat_big_num.num=  (Nat_big_num.pow_int(Nat_big_num.of_int 2)( 32))

(*val word32ToInteger : word32 -> integer*)
let word32ToInteger w:Nat_big_num.num=  (integerFromBitSeq (w32_to_bs w))

(*val word32ToNatural : word32 -> natural*)
let word32ToNatural w:Nat_big_num.num=  (Nat_big_num.abs ( Nat_big_num.modulus(word32ToInteger w) size32))

(*val word32FromInteger : integer -> word32*)
let word32FromInteger i:word32=  (bs_to_w32 (bitSeqFromInteger (Some( 32)) i))

(*val word32FromInt : int -> word32*)
let word32FromInt i:word32=  (bs_to_w32 (bitSeqFromInteger (Some( 32)) (Nat_big_num.of_int i)))

(*val word32FromNatural : natural -> word32*)
let word32FromNatural i:word32=  (word32FromInteger ( i))

(*val word32FromNat : nat -> word32*)
let word32FromNat i:word32=  (word32FromInteger (Nat_big_num.of_int i))

(*val word32FromBoollist : list bool -> word32*)
let word32FromBoollist lst:word32=  ((match bitSeqFromBoolList (List.rev lst) with
 | None -> bs_to_w32(bitSeqFromInteger None (Nat_big_num.of_int 0))
 | Some a -> bs_to_w32 a
))

(*val boolListFromWord32 : word32 -> list bool*)
let boolListFromWord32 w:(bool)list=  (List.rev (boolListFrombitSeq( 32) (w32_to_bs w)))

(*val word32FromNumeral : numeral -> word32*)
let word32FromNumeral w:word32=  (bs_to_w32 (bitSeqFromInteger None (Nat_big_num.of_int w)))

(*val w32Eq : word32 -> word32 -> bool*)
let w32Eq:word32 ->word32 ->bool=  (=)

(*val w32Less : word32 -> word32 -> bool*)
let w32Less bs1 bs2:bool=  (word32BinTest bitSeqLess bs1 bs2)

(*val w32LessEqual : word32 -> word32 -> bool*)
let w32LessEqual bs1 bs2:bool=  (word32BinTest bitSeqLessEqual bs1 bs2)

(*val w32Greater : word32 -> word32 -> bool*)
let w32Greater bs1 bs2:bool=  (word32BinTest bitSeqGreater bs1 bs2)

(*val w32GreaterEqual : word32 -> word32 -> bool*)
let w32GreaterEqual bs1 bs2:bool=  (word32BinTest bitSeqGreaterEqual bs1 bs2)

(*val w32Compare : word32 -> word32 -> ordering*)
let w32Compare bs1 bs2:int=  (word32BinTest bitSeqCompare bs1 bs2)

let instance_Basic_classes_Ord_Word32_word32_dict:(word32)ord_class= ({

  compare_method = w32Compare;

  isLess_method = w32Less;

  isLessEqual_method = w32LessEqual;

  isGreater_method = w32Greater;

  isGreaterEqual_method = w32GreaterEqual})

let instance_Basic_classes_SetType_Word32_word32_dict:(word32)setType_class= ({

  setElemCompare_method = w32Compare})

(*val word32Negate : word32 -> word32*)
let word32Negate:word32 ->word32=  (word32UnaryOp bitSeqNegate)

(*val word32Succ : word32 -> word32*)
let word32Succ:word32 ->word32=  (word32UnaryOp bitSeqSucc)

(*val word32Pred : word32 -> word32*)
let word32Pred:word32 ->word32=  (word32UnaryOp bitSeqPred)

(*val word32Lnot : word32 -> word32*)
let word32Lnot:word32 ->word32=  (word32UnaryOp bitSeqNot)

(*val word32Add : word32 -> word32 -> word32*)
let word32Add:word32 ->word32 ->word32=  (word32BinOp bitSeqAdd)

(*val word32Minus : word32 -> word32 -> word32*)
let word32Minus:word32 ->word32 ->word32=  (word32BinOp bitSeqMinus)

(*val word32Mult : word32 -> word32 -> word32*)
let word32Mult:word32 ->word32 ->word32=  (word32BinOp bitSeqMult)

(*val word32IntegerDivision : word32 -> word32 -> word32*)
let word32IntegerDivision:word32 ->word32 ->word32=  (word32BinOp bitSeqDiv)

(*val word32Division : word32 -> word32 -> word32*)
let word32Division:word32 ->word32 ->word32=  (word32BinOp bitSeqDiv)

(*val word32Remainder : word32 -> word32 -> word32*)
let word32Remainder:word32 ->word32 ->word32=  (word32BinOp bitSeqMod)

(*val word32Land : word32 -> word32 -> word32*)
let word32Land:word32 ->word32 ->word32=  (word32BinOp bitSeqAnd)

(*val word32Lor : word32 -> word32 -> word32*)
let word32Lor:word32 ->word32 ->word32=  (word32BinOp bitSeqOr)

(*val word32Lxor : word32 -> word32 -> word32*)
let word32Lxor:word32 ->word32 ->word32=  (word32BinOp bitSeqXor)

(*val word32Min : word32 -> word32 -> word32*)
let word32Min:word32 ->word32 ->word32=  (word32BinOp (bitSeqMin))

(*val word32Max : word32 -> word32 -> word32*)
let word32Max:word32 ->word32 ->word32=  (word32BinOp (bitSeqMax))

(*val word32Power : word32 -> nat -> word32*)
let word32Power:word32 ->int ->word32=  (word32NatOp bitSeqPow)

(*val word32Asr : word32 -> nat -> word32*)
let word32Asr:word32 ->int ->word32=  (word32NatOp bitSeqArithmeticShiftRight)

(*val word32Lsr : word32 -> nat -> word32*)
let word32Lsr:word32 ->int ->word32=  (word32NatOp bitSeqLogicalShiftRight)

(*val word32Lsl : word32 -> nat -> word32*)
let word32Lsl:word32 ->int ->word32=  (word32NatOp bitSeqShiftLeft)


let instance_Num_NumNegate_Word32_word32_dict:(word32)numNegate_class= ({

  numNegate_method = word32Negate})

let instance_Num_NumAdd_Word32_word32_dict:(word32)numAdd_class= ({

  numAdd_method = word32Add})

let instance_Num_NumMinus_Word32_word32_dict:(word32)numMinus_class= ({

  numMinus_method = word32Minus})

let instance_Num_NumSucc_Word32_word32_dict:(word32)numSucc_class= ({

  succ_method = word32Succ})

let instance_Num_NumPred_Word32_word32_dict:(word32)numPred_class= ({

  pred_method = word32Pred})

let instance_Num_NumMult_Word32_word32_dict:(word32)numMult_class= ({

  numMult_method = word32Mult})

let instance_Num_NumPow_Word32_word32_dict:(word32)numPow_class= ({

  numPow_method = word32Power})

let instance_Num_NumIntegerDivision_Word32_word32_dict:(word32)numIntegerDivision_class= ({

  div_method = word32IntegerDivision})

let instance_Num_NumDivision_Word32_word32_dict:(word32)numDivision_class= ({

  numDivision_method = word32Division})

let instance_Num_NumRemainder_Word32_word32_dict:(word32)numRemainder_class= ({

  mod_method = word32Remainder})

let instance_Basic_classes_OrdMaxMin_Word32_word32_dict:(word32)ordMaxMin_class= ({

  max_method = word32Max;

  min_method = word32Min})

let instance_Word_WordNot_Word32_word32_dict:(word32)wordNot_class= ({

  lnot_method = word32Lnot})

let instance_Word_WordAnd_Word32_word32_dict:(word32)wordAnd_class= ({

  land_method = word32Land})

let instance_Word_WordOr_Word32_word32_dict:(word32)wordOr_class= ({

  lor_method = word32Lor})

let instance_Word_WordXor_Word32_word32_dict:(word32)wordXor_class= ({

  lxor_method = word32Lxor})

let instance_Word_WordLsl_Word32_word32_dict:(word32)wordLsl_class= ({

  lsl_method = word32Lsl})

let instance_Word_WordLsr_Word32_word32_dict:(word32)wordLsr_class= ({

  lsr_method = word32Lsr})

let instance_Word_WordAsr_Word32_word32_dict:(word32)wordAsr_class= ({

  asr_method = word32Asr})

(*val word32UGT : word32 -> word32 -> bool*)
let word32UGT a b:bool=  (Nat_big_num.greater (word32ToNatural a) (word32ToNatural b))

(*val word32ULT : word32 -> word32 -> bool*)
let word32ULT a b:bool=  (Nat_big_num.less (word32ToNatural a) (word32ToNatural b))

(*val word32UGE : word32 -> word32 -> bool*)
let word32UGE a b:bool=  (Nat_big_num.greater_equal (word32ToNatural a) (word32ToNatural b))

