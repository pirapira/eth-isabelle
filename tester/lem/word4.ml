(*Generated by Lem from lem/word4.lem.*)
(*
  Copyright 2016 Sami MÃ¤kelÃ¤

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*)
open Lem_pervasives
open Lem_word

type word4 = W4 of bool * bool list

(* perhaps should truncate here? *)
(*val bs_to_w4 : bitSequence -> word4*)
let bs_to_w4 seq:word4=  ((match resizeBitSeq (Some( 4)) seq with
 | BitSeq( _, s, b) -> W4( s, b)
))

(*val w4_to_bs : word4 -> bitSequence*)
let w4_to_bs (W4( s, b)):bitSequence=  (BitSeq( (Some( 4)), s, b))

(*val word4BinTest : forall 'a. (bitSequence -> bitSequence -> 'a) -> word4 -> word4 -> 'a*)
let word4BinTest binop w1 w2:'a=  (binop (w4_to_bs w1) (w4_to_bs w2))

(*val word4BinOp : (bitSequence -> bitSequence -> bitSequence) -> word4 -> word4 -> word4*)
let word4BinOp binop w1 w2:word4=  (bs_to_w4 (binop (w4_to_bs w1) (w4_to_bs w2)))

(*val word4NatOp : (bitSequence -> nat -> bitSequence) -> word4 -> nat -> word4*)
let word4NatOp binop w1 n:word4=  (bs_to_w4 (binop (w4_to_bs w1) n))

(*val word4UnaryOp : (bitSequence -> bitSequence) -> word4 -> word4*)
let word4UnaryOp op w:word4=  (bs_to_w4 (op (w4_to_bs w)))

(*val word4ToNat : word4 -> nat*)
let word4ToNat w:int=  (abs ( Nat_num.int_mod(Nat_big_num.to_int (integerFromBitSeq (w4_to_bs w)))( 16)))

(*val word4ToInt : word4 -> int*)
let word4ToInt w:int=  (Nat_big_num.to_int (integerFromBitSeq (w4_to_bs w)))

(*val word4ToUInt : word4 -> int*)
let word4ToUInt w:int=  (Nat_num.int_mod (word4ToInt w)( 16))

(*val word4FromInteger : integer -> word4*)
let word4FromInteger i:word4=  (bs_to_w4 (bitSeqFromInteger (Some( 4)) i))

(*val word4FromInt : int -> word4*)
let word4FromInt i:word4=  (bs_to_w4 (bitSeqFromInteger (Some( 4)) (Nat_big_num.of_int i)))

(*val word4FromNat : nat -> word4*)
let word4FromNat i:word4=  (word4FromInteger (Nat_big_num.of_int i))

(*val word4FromNatural : natural -> word4*)
let word4FromNatural i:word4=  (word4FromInteger ( i))

(*val word4FromBoollist : list bool -> word4*)
let word4FromBoollist lst:word4=  ((match bitSeqFromBoolList (List.rev lst) with
 | None -> bs_to_w4(bitSeqFromInteger None (Nat_big_num.of_int 0))
 | Some a -> bs_to_w4 a
))

(*val boolListFromWord4 : word4 -> list bool*)
let boolListFromWord4 w:(bool)list=  (List.rev (boolListFrombitSeq( 4) (w4_to_bs w)))

(*val word4FromNumeral : numeral -> word4*)
let word4FromNumeral w:word4=  (bs_to_w4 (bitSeqFromInteger None (Nat_big_num.of_int w)))

(*val w4Eq : word4 -> word4 -> bool*)
let w4Eq:word4 ->word4 ->bool=  (=)

(*val w4Less : word4 -> word4 -> bool*)
let w4Less bs1 bs2:bool=  (word4BinTest bitSeqLess bs1 bs2)

(*val w4LessEqual : word4 -> word4 -> bool*)
let w4LessEqual bs1 bs2:bool=  (word4BinTest bitSeqLessEqual bs1 bs2)

(*val w4Greater : word4 -> word4 -> bool*)
let w4Greater bs1 bs2:bool=  (word4BinTest bitSeqGreater bs1 bs2)

(*val w4GreaterEqual : word4 -> word4 -> bool*)
let w4GreaterEqual bs1 bs2:bool=  (word4BinTest bitSeqGreaterEqual bs1 bs2)

(*val w4Compare : word4 -> word4 -> ordering*)
let w4Compare bs1 bs2:int=  (word4BinTest bitSeqCompare bs1 bs2)

let instance_Basic_classes_Ord_Word4_word4_dict:(word4)ord_class= ({

  compare_method = w4Compare;

  isLess_method = w4Less;

  isLessEqual_method = w4LessEqual;

  isGreater_method = w4Greater;

  isGreaterEqual_method = w4GreaterEqual})

let instance_Basic_classes_SetType_Word4_word4_dict:(word4)setType_class= ({

  setElemCompare_method = w4Compare})

(*val word4Negate : word4 -> word4*)
let word4Negate:word4 ->word4=  (word4UnaryOp bitSeqNegate)

(*val word4Succ : word4 -> word4*)
let word4Succ:word4 ->word4=  (word4UnaryOp bitSeqSucc)

(*val word4Pred : word4 -> word4*)
let word4Pred:word4 ->word4=  (word4UnaryOp bitSeqPred)

(*val word4Lnot : word4 -> word4*)
let word4Lnot:word4 ->word4=  (word4UnaryOp bitSeqNot)

(*val word4Add : word4 -> word4 -> word4*)
let word4Add:word4 ->word4 ->word4=  (word4BinOp bitSeqAdd)

(*val word4Minus : word4 -> word4 -> word4*)
let word4Minus:word4 ->word4 ->word4=  (word4BinOp bitSeqMinus)

(*val word4Mult : word4 -> word4 -> word4*)
let word4Mult:word4 ->word4 ->word4=  (word4BinOp bitSeqMult)

(*val word4IntegerDivision : word4 -> word4 -> word4*)
let word4IntegerDivision:word4 ->word4 ->word4=  (word4BinOp bitSeqDiv)

(*val word4Division : word4 -> word4 -> word4*)
let word4Division:word4 ->word4 ->word4=  (word4BinOp bitSeqDiv)

(*val word4Remainder : word4 -> word4 -> word4*)
let word4Remainder:word4 ->word4 ->word4=  (word4BinOp bitSeqMod)

(*val word4Land : word4 -> word4 -> word4*)
let word4Land:word4 ->word4 ->word4=  (word4BinOp bitSeqAnd)

(*val word4Lor : word4 -> word4 -> word4*)
let word4Lor:word4 ->word4 ->word4=  (word4BinOp bitSeqOr)

(*val word4Lxor : word4 -> word4 -> word4*)
let word4Lxor:word4 ->word4 ->word4=  (word4BinOp bitSeqXor)

(*val word4Min : word4 -> word4 -> word4*)
let word4Min:word4 ->word4 ->word4=  (word4BinOp (bitSeqMin))

(*val word4Max : word4 -> word4 -> word4*)
let word4Max:word4 ->word4 ->word4=  (word4BinOp (bitSeqMax))

(*val word4Power : word4 -> nat -> word4*)
let word4Power:word4 ->int ->word4=  (word4NatOp bitSeqPow)

(*val word4Asr : word4 -> nat -> word4*)
let word4Asr:word4 ->int ->word4=  (word4NatOp bitSeqArithmeticShiftRight)

(*val word4Lsr : word4 -> nat -> word4*)
let word4Lsr:word4 ->int ->word4=  (word4NatOp bitSeqLogicalShiftRight)

(*val word4Lsl : word4 -> nat -> word4*)
let word4Lsl:word4 ->int ->word4=  (word4NatOp bitSeqShiftLeft)


let instance_Num_NumNegate_Word4_word4_dict:(word4)numNegate_class= ({

  numNegate_method = word4Negate})

let instance_Num_NumAdd_Word4_word4_dict:(word4)numAdd_class= ({

  numAdd_method = word4Add})

let instance_Num_NumMinus_Word4_word4_dict:(word4)numMinus_class= ({

  numMinus_method = word4Minus})

let instance_Num_NumSucc_Word4_word4_dict:(word4)numSucc_class= ({

  succ_method = word4Succ})

let instance_Num_NumPred_Word4_word4_dict:(word4)numPred_class= ({

  pred_method = word4Pred})

let instance_Num_NumMult_Word4_word4_dict:(word4)numMult_class= ({

  numMult_method = word4Mult})

let instance_Num_NumPow_Word4_word4_dict:(word4)numPow_class= ({

  numPow_method = word4Power})

let instance_Num_NumIntegerDivision_Word4_word4_dict:(word4)numIntegerDivision_class= ({

  div_method = word4IntegerDivision})

let instance_Num_NumDivision_Word4_word4_dict:(word4)numDivision_class= ({

  numDivision_method = word4Division})

let instance_Num_NumRemainder_Word4_word4_dict:(word4)numRemainder_class= ({

  mod_method = word4Remainder})

let instance_Basic_classes_OrdMaxMin_Word4_word4_dict:(word4)ordMaxMin_class= ({

  max_method = word4Max;

  min_method = word4Min})

let instance_Word_WordNot_Word4_word4_dict:(word4)wordNot_class= ({

  lnot_method = word4Lnot})

let instance_Word_WordAnd_Word4_word4_dict:(word4)wordAnd_class= ({

  land_method = word4Land})

let instance_Word_WordOr_Word4_word4_dict:(word4)wordOr_class= ({

  lor_method = word4Lor})

let instance_Word_WordXor_Word4_word4_dict:(word4)wordXor_class= ({

  lxor_method = word4Lxor})

let instance_Word_WordLsl_Word4_word4_dict:(word4)wordLsl_class= ({

  lsl_method = word4Lsl})

let instance_Word_WordLsr_Word4_word4_dict:(word4)wordLsr_class= ({

  lsr_method = word4Lsr})

let instance_Word_WordAsr_Word4_word4_dict:(word4)wordAsr_class= ({

  asr_method = word4Asr})

(*val word4UGT : word4 -> word4 -> bool*)
let word4UGT a b:bool=  (word4ToNat a > word4ToNat b)

