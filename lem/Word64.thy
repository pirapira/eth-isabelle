chapter {* Generated by Lem from word64.lem. *}

theory "Word64" 

imports 
 	 Main
	 "Lem_pervasives" 
	 "Lem_word" 

begin 

(*
  Copyright 2016 Sami MÃ¤kelÃ¤

   Licensed under the Apache License, Version 2.0 (the License);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an AS IS BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*)

(*open import Pervasives*)
(*open import Word*)

(*type word64 = W64 of bool * list bool*)

(* perhaps should truncate here? *)
(*val bs_to_w64 : bitSequence -> word64*)
(*let bs_to_w64 seq=  match resizeBitSeq (Just 64) seq with
 | BitSeq _ s b -> W64 s b
end*)

(*val w64_to_bs : word64 -> bitSequence*)
(*let w64_to_bs (W64 s b)=  BitSeq (Just 64) s b*)

(*val word64BinTest : forall 'a. (bitSequence -> bitSequence -> 'a) -> word64 -> word64 -> 'a*)
definition word64BinTest  :: "(bitSequence \<Rightarrow> bitSequence \<Rightarrow> 'a)\<Rightarrow> 64 word \<Rightarrow> 64 word \<Rightarrow> 'a "  where 
     " word64BinTest binop w1 w2 = ( binop ((\<lambda> w .  bitSeqFromInteger (Some 64) (sint w)) w1) ((\<lambda> w .  bitSeqFromInteger (Some 64) (sint w)) w2))"


(*val word64BinOp : (bitSequence -> bitSequence -> bitSequence) -> word64 -> word64 -> word64*)
definition word64BinOp  :: "(bitSequence \<Rightarrow> bitSequence \<Rightarrow> bitSequence)\<Rightarrow> 64 word \<Rightarrow> 64 word \<Rightarrow> 64 word "  where 
     " word64BinOp binop w1 w2 = ( (\<lambda> w .  word_of_int (integerFromBitSeq w)) (binop ((\<lambda> w .  bitSeqFromInteger (Some 64) (sint w)) w1) ((\<lambda> w .  bitSeqFromInteger (Some 64) (sint w)) w2)))"


(*val word64NatOp : (bitSequence -> nat -> bitSequence) -> word64 -> nat -> word64*)
definition word64NatOp  :: "(bitSequence \<Rightarrow> nat \<Rightarrow> bitSequence)\<Rightarrow> 64 word \<Rightarrow> nat \<Rightarrow> 64 word "  where 
     " word64NatOp binop w1 n = ( (\<lambda> w .  word_of_int (integerFromBitSeq w)) (binop ((\<lambda> w .  bitSeqFromInteger (Some 64) (sint w)) w1) n))"


(*val word64UnaryOp : (bitSequence -> bitSequence) -> word64 -> word64*)
definition word64UnaryOp  :: "(bitSequence \<Rightarrow> bitSequence)\<Rightarrow> 64 word \<Rightarrow> 64 word "  where 
     " word64UnaryOp op1 w = ( (\<lambda> w .  word_of_int (integerFromBitSeq w)) (op1 ((\<lambda> w .  bitSeqFromInteger (Some 64) (sint w)) w)))"


(*val size64 : integer*)
definition size64  :: " int "  where 
     " size64 = (( 2 :: int) ^( 64 :: nat))"


(*val word64ToInteger : word64 -> integer*)
(*let word64ToInteger w=  integerFromBitSeq (w64_to_bs w)*)

(*val word64ToNatural : word64 -> natural*)
(*let word64ToNatural w=  naturalFromInteger ((Instance_Num_NumRemainder_Num_integer.mod) (word64ToInteger w) size64)*)

(*val word64FromInteger : integer -> word64*)
(*let word64FromInteger i=  bs_to_w64 (bitSeqFromInteger (Just 64) i)*)

(*val word64FromInt : int -> word64*)
(*let word64FromInt i=  bs_to_w64 (bitSeqFromInteger (Just 64) (integerFromInt i))*)

(*val word64FromNatural : natural -> word64*)
definition word64FromNatural  :: " nat \<Rightarrow> 64 word "  where 
     " word64FromNatural i = ( (\<lambda> i .  word_of_int ( i)) (int i))"


(*val word64FromNat : nat -> word64*)
definition word64FromNat  :: " nat \<Rightarrow> 64 word "  where 
     " word64FromNat i = ( (\<lambda> i .  word_of_int ( i)) (int i))"


(*val word64FromBoollist : list bool -> word64*)
(*let word64FromBoollist lst=  match bitSeqFromBoolList (List.reverse lst) with
 | Nothing -> bs_to_w64 0
 | Just a -> bs_to_w64 a
end*)

(*val boolListFromWord64 : word64 -> list bool*)
(*let boolListFromWord64 w=  List.reverse (boolListFrombitSeq 64 (w64_to_bs w))*)

(*val word64FromNumeral : numeral -> word64*)
(*let word64FromNumeral w=  bs_to_w64 (Instance_Num_Numeral_Word_bitSequence.fromNumeral w)*)

(*val w64Eq : word64 -> word64 -> bool*)
definition w64Eq  :: " 64 word \<Rightarrow> 64 word \<Rightarrow> bool "  where 
     " w64Eq = ( (op=))"


(*val w64Less : word64 -> word64 -> bool*)
(*let w64Less bs1 bs2=  word64BinTest  
  (Instance_Basic_classes_Ord_Word_bitSequence.<) bs1 bs2*)

(*val w64LessEqual : word64 -> word64 -> bool*)
(*let w64LessEqual bs1 bs2=  word64BinTest  
  (Instance_Basic_classes_Ord_Word_bitSequence.<=) bs1 bs2*)

(*val w64Greater : word64 -> word64 -> bool*)
(*let w64Greater bs1 bs2=  word64BinTest  
  (Instance_Basic_classes_Ord_Word_bitSequence.>) bs1 bs2*)

(*val w64GreaterEqual : word64 -> word64 -> bool*)
(*let w64GreaterEqual bs1 bs2=  word64BinTest  
  (Instance_Basic_classes_Ord_Word_bitSequence.>=) bs1 bs2*)

(*val w64Compare : word64 -> word64 -> ordering*)
(*let w64Compare bs1 bs2=  word64BinTest  
  Instance_Basic_classes_Ord_Word_bitSequence.compare bs1 bs2*)

definition instance_Basic_classes_Ord_Word64_word64_dict  :: "( 64 word)Ord_class "  where 
     " instance_Basic_classes_Ord_Word64_word64_dict = ((|

  compare_method = (genericCompare word_sless w64Eq),

  isLess_method = word_sless,

  isLessEqual_method = word_sle,

  isGreater_method = (\<lambda> x y. word_sless y x),

  isGreaterEqual_method = (\<lambda> x y. word_sle y x)|) )"


(*val word64Negate : word64 -> word64*)
(*let word64Negate=  word64UnaryOp  
  Instance_Num_NumNegate_Word_bitSequence.~*)

(*val word64Succ : word64 -> word64*)
(*let word64Succ=  word64UnaryOp  
  Instance_Num_NumSucc_Word_bitSequence.succ*)

(*val word64Pred : word64 -> word64*)
(*let word64Pred=  word64UnaryOp  
  Instance_Num_NumPred_Word_bitSequence.pred*)

(*val word64Lnot : word64 -> word64*)
(*let word64Lnot=  word64UnaryOp  
  Instance_Word_WordNot_Word_bitSequence.lnot*)

(*val word64Add : word64 -> word64 -> word64*)
(*let word64Add=  word64BinOp  
  (Instance_Num_NumAdd_Word_bitSequence.+)*)

(*val word64Minus : word64 -> word64 -> word64*)
(*let word64Minus=  word64BinOp  
  (Instance_Num_NumMinus_Word_bitSequence.-)*)

(*val word64Mult : word64 -> word64 -> word64*)
(*let word64Mult=  word64BinOp  
  ( Instance_Num_NumMult_Word_bitSequence.* )*)

(*val word64IntegerDivision : word64 -> word64 -> word64*)
(*let word64IntegerDivision=  word64BinOp  
  (Instance_Num_NumDivision_Word_bitSequence./)*)

(*val word64Division : word64 -> word64 -> word64*)
(*let word64Division=  word64BinOp  
  Instance_Num_NumIntegerDivision_Word_bitSequence.div*)

(*val word64Remainder : word64 -> word64 -> word64*)
(*let word64Remainder=  word64BinOp  
  (Instance_Num_NumRemainder_Word_bitSequence.mod)*)

(*val word64Land : word64 -> word64 -> word64*)
(*let word64Land=  word64BinOp  
  (Instance_Word_WordAnd_Word_bitSequence.land)*)

(*val word64Lor : word64 -> word64 -> word64*)
(*let word64Lor=  word64BinOp  
  (Instance_Word_WordOr_Word_bitSequence.lor)*)

(*val word64Lxor : word64 -> word64 -> word64*)
(*let word64Lxor=  word64BinOp  
  (Instance_Word_WordXor_Word_bitSequence.lxor)*)

(*val word64Min : word64 -> word64 -> word64*)
(*let word64Min=  word64BinOp (Instance_Basic_classes_OrdMaxMin_Word_bitSequence.min)*)

(*val word64Max : word64 -> word64 -> word64*)
(*let word64Max=  word64BinOp (Instance_Basic_classes_OrdMaxMin_Word_bitSequence.max)*)

(*val word64Power : word64 -> nat -> word64*)
(*let word64Power=  word64NatOp  
  ( Instance_Num_NumPow_Word_bitSequence.** )*)

(*val word64Asr : word64 -> nat -> word64*)
(*let word64Asr=  word64NatOp  
  (Instance_Word_WordAsr_Word_bitSequence.asr)*)

(*val word64Lsr : word64 -> nat -> word64*)
(*let word64Lsr=  word64NatOp  
  (Instance_Word_WordLsr_Word_bitSequence.lsr)*)

(*val word64Lsl : word64 -> nat -> word64*)
(*let word64Lsl=  word64NatOp  
  (Instance_Word_WordLsl_Word_bitSequence.lsl)*)


definition instance_Num_NumNegate_Word64_word64_dict  :: "( 64 word)NumNegate_class "  where 
     " instance_Num_NumNegate_Word64_word64_dict = ((|

  numNegate_method = (\<lambda> i. - i)|) )"


definition instance_Num_NumAdd_Word64_word64_dict  :: "( 64 word)NumAdd_class "  where 
     " instance_Num_NumAdd_Word64_word64_dict = ((|

  numAdd_method = (op+)|) )"


definition instance_Num_NumMinus_Word64_word64_dict  :: "( 64 word)NumMinus_class "  where 
     " instance_Num_NumMinus_Word64_word64_dict = ((|

  numMinus_method = (op-)|) )"


definition instance_Num_NumSucc_Word64_word64_dict  :: "( 64 word)NumSucc_class "  where 
     " instance_Num_NumSucc_Word64_word64_dict = ((|

  succ_method = (\<lambda> n. n + 1)|) )"


definition instance_Num_NumPred_Word64_word64_dict  :: "( 64 word)NumPred_class "  where 
     " instance_Num_NumPred_Word64_word64_dict = ((|

  pred_method = (\<lambda> n. n - 1)|) )"


definition instance_Num_NumMult_Word64_word64_dict  :: "( 64 word)NumMult_class "  where 
     " instance_Num_NumMult_Word64_word64_dict = ((|

  numMult_method = (op*)|) )"


definition instance_Num_NumPow_Word64_word64_dict  :: "( 64 word)NumPow_class "  where 
     " instance_Num_NumPow_Word64_word64_dict = ((|

  numPow_method = (op^)|) )"


definition instance_Num_NumIntegerDivision_Word64_word64_dict  :: "( 64 word)NumIntegerDivision_class "  where 
     " instance_Num_NumIntegerDivision_Word64_word64_dict = ((|

  div_method = (op div)|) )"


definition instance_Num_NumDivision_Word64_word64_dict  :: "( 64 word)NumDivision_class "  where 
     " instance_Num_NumDivision_Word64_word64_dict = ((|

  numDivision_method = (op div)|) )"


definition instance_Num_NumRemainder_Word64_word64_dict  :: "( 64 word)NumRemainder_class "  where 
     " instance_Num_NumRemainder_Word64_word64_dict = ((|

  mod_method = (op mod)|) )"


definition instance_Basic_classes_OrdMaxMin_Word64_word64_dict  :: "( 64 word)OrdMaxMin_class "  where 
     " instance_Basic_classes_OrdMaxMin_Word64_word64_dict = ((|

  max_method = max,

  min_method = min |) )"


definition instance_Word_WordNot_Word64_word64_dict  :: "( 64 word)WordNot_class "  where 
     " instance_Word_WordNot_Word64_word64_dict = ((|

  lnot_method = (\<lambda> w. (NOT w))|) )"


definition instance_Word_WordAnd_Word64_word64_dict  :: "( 64 word)WordAnd_class "  where 
     " instance_Word_WordAnd_Word64_word64_dict = ((|

  land_method = (op AND)|) )"


definition instance_Word_WordOr_Word64_word64_dict  :: "( 64 word)WordOr_class "  where 
     " instance_Word_WordOr_Word64_word64_dict = ((|

  lor_method = (op OR)|) )"


definition instance_Word_WordXor_Word64_word64_dict  :: "( 64 word)WordXor_class "  where 
     " instance_Word_WordXor_Word64_word64_dict = ((|

  lxor_method = (op XOR)|) )"


definition instance_Word_WordLsl_Word64_word64_dict  :: "( 64 word)WordLsl_class "  where 
     " instance_Word_WordLsl_Word64_word64_dict = ((|

  lsl_method = (op<<)|) )"


definition instance_Word_WordLsr_Word64_word64_dict  :: "( 64 word)WordLsr_class "  where 
     " instance_Word_WordLsr_Word64_word64_dict = ((|

  lsr_method = (op>>)|) )"


definition instance_Word_WordAsr_Word64_word64_dict  :: "( 64 word)WordAsr_class "  where 
     " instance_Word_WordAsr_Word64_word64_dict = ((|

  asr_method = (op>>>)|) )"


(*val word64UGT : word64 -> word64 -> bool*)
(*let word64UGT a b=  (Instance_Basic_classes_Ord_Num_natural.>) (word64ToNatural a) (word64ToNatural b)*)

(*val word64ULT : word64 -> word64 -> bool*)
(*let word64ULT a b=  (Instance_Basic_classes_Ord_Num_natural.<) (word64ToNatural a) (word64ToNatural b)*)

(*val word64UGE : word64 -> word64 -> bool*)
(*let word64UGE a b=  (Instance_Basic_classes_Ord_Num_natural.>=) (word64ToNatural a) (word64ToNatural b)*)

end
